<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>melody</title>
  
  <subtitle>keep moving</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://melodyyyyy.com/"/>
  <updated>2018-07-11T07:32:53.113Z</updated>
  <id>http://melodyyyyy.com/</id>
  
  <author>
    <name>melody</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://melodyyyyy.com/2018/06/28/%E4%BC%98%E5%8C%96/"/>
    <id>http://melodyyyyy.com/2018/06/28/优化/</id>
    <published>2018-06-28T08:10:42.000Z</published>
    <updated>2018-07-11T07:32:53.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端优化的目的"><a href="#前端优化的目的" class="headerlink" title="前端优化的目的"></a>前端优化的目的</h3><p>前端包括HTML、CSS、Javascript、Image、Flash等各种各样的资源，针对方方面面的资源有不同的优化方式，那么优化的目的是什么呢？<br>1.对于用户而言，优化可以让页面加载更快，使得用户的操作能够及时被响应，能够给用户提供更加友好的体验；<br>2.从服务商而言，优化能够减少页面请求数，减小请求所用带宽，节省可观的资源。<br>因此恰当的优化不仅能改善站点的用户体验并且能节省相当的资源利用。</p><h3 id="前端优化步骤"><a href="#前端优化步骤" class="headerlink" title="前端优化步骤"></a>前端优化步骤</h3><p>提到前端优化，必然就会想到大名鼎鼎的雅虎黄金准则，可以分为7大类35条：</p><table><thead><tr><th style="text-align:left">网页内容</th><th style="text-align:left">服务器</th><th style="text-align:left">Cookie</th></tr></thead><tbody><tr><td style="text-align:left">减少HTTP请求次数<br>减少DNS查询次数<br>避免页面跳转<br>缓存Ajax<br>延迟加载<br>提前加载<br>减少 DOM元素数量<br>用域名划分页面内容<br>使 iframe数量最少<br>避免 404错误</td><td style="text-align:left">使用CDN<br> 添加 Expires (或者Cache-control)报文头<br>Gzip压缩文件内容<br>配置ETags<br>尽早刷新输出缓冲<br>使用GET来完成AJAX请求<br>避免空的图像来源<br>&nbsp;<br>&nbsp;<br>&nbsp;</td><td style="text-align:left">减小Cookie体积<br>对于页面内容使用无coockie域名<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</td></tr></tbody></table><table><thead><tr><th style="text-align:left">CSS</th><th style="text-align:left">Javascript</th><th style="text-align:left">图片</th><th style="text-align:left">移动客户端</th></tr></thead><tbody><tr><td style="text-align:left">把样式表置于顶部<br>避免使用CSS表达式<br>用<link>代替@import<br>避免使用Filter<br>&nbsp;<br>&nbsp;</td><td style="text-align:left">把脚本置于页面底部<br>使用外部JavaScript和CSS<br>削减JavaScript和CSS<br>剔除重复脚本<br>减少DOM访问<br>开发智能事件处理程序</td><td style="text-align:left">优化图像<br>优化CSS Spirite<br>不要在HTML中缩放图像<br>favicon.ico要小而且可缓存<br>&nbsp;<br>&nbsp;</td><td style="text-align:left">保持单个内容小于25K<br>打包组件成复合文本<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</td></tr></tbody></table><ul><li><strong>网页内容</strong><ol><li>减少 HTTP请求次数<br>HTTP请求是要开销的，终端用户响应的时间中，有80%用于下载各项内容（images, stylesheets, javascripts, scripts, flash等）。减少请求次数是缩短响应时间的关键，可以通过捆绑文件、CSS Sprites、 Image Maps、Inline images等技巧实现。</li><li>减少DNS查询次数<br>DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。</li><li>避免页面跳转<br>跳转是使用 301和 302代码实现的。下面是一个响应代码为 301的 HTTP头:<br>HTTP/1.1 301 Moved Permanently<br>Location: <a href="http://example.com/newuri" target="_blank" rel="noopener">http://example.com/newuri</a><br>Content-Type: text/html<br>浏览器会把用户指向到 Location中指定的 URL。头文件中的所有信息在一次跳转中都是必需的,内容部分可以为空。301和302响应都不会被缓存，除非增加一个额外的头选项,如 Expires或者 Cache-Control来指定它缓存。如果你必须要跳转的时候,最好的方法就是使用标准的 3XXHTTP状态代码,这主要是为了确保“后退”按钮可以正确地使用。<br>但是要记住跳转会降低用户体验。在用户和 HTML文档中间增加一个跳转,会拖延页面中所有元素的显示,因为在 HTML文件被加载前任何文件(图像、 Flash等)都不会被下载。<br>有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。 这种现象发生在当 URL本该有斜杠(/)却被忽略掉时。例如,当我们要访问 <a href="http://astrology.yahoo.com/astrology" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology</a> 时,实际上返回的是一个包含 301代码的跳转,它指向的是 <a href="http://astrology.yahoo.com/astrology/" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/</a>  (注意末尾的斜杠)。在 Apache服务器中可以使用 Alias 或者 mod_rewrite或者 the DirectorySlash来避免。</li><li>缓存Ajax<br>Ajax 经常被提及的一个好处就是由于其从后台服务器传输信息 的异步性而为用户带来的反馈的即时性。但是,使用 Ajax并不能保证用户不会在等待异步的 JavaScript和 XML响应上花费时间。在很多应用中,用户是否需要等待响应取决于 Ajax如何来使用。例如,在一个基于 Web的 Email客户端中,用户必须等待 Ajax返回符合他们条件的邮件查询结果。记住一点,“异步”并不异味着“即时”,这很重要。</li><li>延迟加载<br>这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。<br>Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。</li><li>提前加载<br>预加载和后加载看起来似乎恰恰相反,但实际上预加载是为了实 现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容(如图像、样式表和脚本)。使用这种方法,当用户要访问下一个页面时,页面中的内容 大部分已经加载到缓存中了,因此可以大大改善访问速度。</li><li>减少DOM元素数量<br>一个复杂的页面意味着需要下载更多数据,同时也意味着 JavaScript遍历 DOM的效率越慢。比如当你增加一个事件句柄时在 500和 5000个 DOM元素中循环效果肯定是不一样的。</li><li>根据域名划分内容<br>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于 DNS查找带来的影响你首先要确保你使用的域名数量在 2个到 4个之间。例如,你可以把用到的 HTML内容和动态内容放在 <a href="http://www.example.org/" target="_blank" rel="noopener">http://www.example.org/</a> 上,而把页面各种组件(图片、脚本、 CSS)分别存放在 statics1.example.org和 statics.example.org上。</li><li>使 iframe的数量最小<br>iframe的缺点主要为即使内容为空,加载也需要时间、会阻止页面加载、没有语意。</li><li>避免404<br>HTTP 请求时间消耗是很大的,因此使用HTTP请求来获得一个没有用处的响应(例如404没有找到页面)是完全没有必要的,它只会降低用户体验而不会有一点好处。最糟糕的情况是指向外部JavaScript的链接出现问题并返回404代码。首先,这种加载会破坏并行加载;其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。</li></ol></li><li><strong>服务器</strong><ol><li>使用CDN<br>用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。</li><li>为文件头指定Expires或Cache-Control<br>对于静态内容:设置文件头过期时间Expires的值为“Never expire”(永不过期)<br>对于动态内容:使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求</li><li>Gzip压缩传输文件<br>Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。值得注意的是pdf文件可以从需要被压缩的类型中剔除，因为pdf文件本身已经压缩，gzip对其效果不大，而且会浪费CPU。</li><li>配置ETags<br>Entity tags(ETags)(实体标签)是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制(“实体”就是所说的“内 容”,包括图片、脚本、样式表等)。增加ETag为实体的验证提供了一个比使用“last-modified date(上次编辑时间)”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。<br>如果你没有使用ETag提供的灵活的验证模式,那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳的。去掉 ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中,只需要在配置文件中简单添加下面一行代码就可以了: FileETag none</li><li>尽早刷新输出缓冲<br>当用户请求一个页面时,无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间,浏览器会一直空闲等待数据返回。在PHP中,你可以使用flush()方法,它允许你把已经编译的好的部分HTML响应文件先发送给浏览器,这时浏览器就会可以下载文件中的内容(脚本等)而后台同时处理剩余的HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。</li><li>使用GET来完成AJAX请求<br>浏览器在实现XMLHttpRequest POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使用Ajax请求数据的时候尽量通过GET来完成。</li><li>避免空的图片src<br>空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。<br>浏览器如此实现也是根据RFC 3986 - Uniform Resource Identifiers标准，空的src被定义为当前页面。</li></ol></li><li><strong>Cookie</strong><ol><li>减少Cookie大小<br>Cookie被用来做认证或个性化设置，其信息被包含在http报文头中，对于cookie我们要注意以下几点，来提高请求的响应速度，<br>去除没有必要的cookie，如果网页不需要cookie就完全禁掉<br>将cookie的大小减到最小<br>注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain<br>设置合适的过期时间，比较长的过期时间可以提高响应速度。</li><li>页面内容使用无cookie域名<br>大多数网站的静态资源都没必要cookie，我们可以采用不同的domain来单独存放这些静态文件，这样做不仅可以减少cookie大小从而提高响应速度，还有一个好处是有些proxy拒绝缓存带有cookie的内容，如果能将这些静态资源cookie去除，那就可以得到这些proxy的缓存支持。<br>常见的划分domain的方式是将静态文件放在static.example.com，动态内容放在www.example.com。<br>也有一些网站需要在二级域名上应用cookie，所有的子域都会继承，这种情况下一般会再购买一个专门的域名来存放cookie-free的静态资源。例如Yahoo!的yimg.com，YouTube的ytimg.com等。</li></ol></li><li><strong>CSS</strong><ol><li>将样式表置顶<br>经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。</li><li>避免CSS表达式<br>CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。</li><li>用<link>代替@import<br>避免使用@import的原因很简单，因为它相当于将css放在网页内容底部。</li><li>避免使用Filters<br>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素(不仅仅是图片)它都会运算一次,增加了内存开支,因此它的问题是多方面的。<br>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替,这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</li></ol></li><li><strong>Javascript</strong><ol><li>把脚本置于页面底部<br>HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。<br>因此对于脚本提速，我们可以考虑以下方式，<br>把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。<br>现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。<br>HTML5中新加了async关键字，可以让脚本异步执行。</li><li>使用外部Javascirpt和CSS文件<br>使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。<br>同时将Javascript和CSS从inline变为external也减小了网页内容的大小。<br>使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。</li><li>精简Javascript和CSS<br>精简就是将Javascript或CSS中的空格和注释全去掉.</li><li>去除重复脚本<br>重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。</li><li>减少DOM访问<br>通过Javascript访问DOM元素没有我们想象中快，元素多的网页尤其慢，对于Javascript对DOM的访问我们要注意：<br>缓存已经访问过的元素<br>Offline更新节点然后再加回DOM Tree<br>避免通过Javascript修复layout</li><li>使用智能事件处理<br>有时候我们会感觉到页面反应迟钝,这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation(事件代理)是一种好方法了。如果你在一个p中有10个按钮,你只需要在p上附加一次事件句柄就可以了,而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。</li></ol></li><li><strong>图片</strong><ol><li>优化图像<br>当美工完成了网站的图片设计后，我们可以在上传图片之前对其做以下优化<br>检查GIF图片中图像颜色的数量是否和调色板规格一致。如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。可以使用imagemagick检查：<br>identify -verbose image.gif<br>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。下面这条简单的命令可以安全地把GIF格式转换为PNG格式：<br>convert image.gif image.png<br>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：<br>pngcrush image.png -rem alla -reduce -brute result.png<br>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息<br>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</li><li>优化CSS Sprite<br>Spirite中水平排列图片，垂直排列会增加文件大小；<br>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；<br>不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。</li><li>不要在HTML中缩放图片<br>不要通过图片缩放来适应页面，如果你需要小图片，就直接使用小图片吧。</li><li>使用小且可缓存的favicon.ico<br>网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以我们要确保这个图标<br>存在<br>文件尽量小，最好小于1k<br>设置一个长的过期时间</li></ol></li><li><strong>移动客户端</strong><ol><li>保持单个内容小于25KB<br>这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。</li><li>打包组建成符合文档<br>把页面内容打包成复合文本就如同带有多附件的Email,它能够使你在一个HTTP请求中取得多个组件(切记:HTTP请求是很奢侈的)。当你使用这条规 则时,首先要确定用户代理是否支持(iPhone就不支持)。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前端优化的目的&quot;&gt;&lt;a href=&quot;#前端优化的目的&quot; class=&quot;headerlink&quot; title=&quot;前端优化的目的&quot;&gt;&lt;/a&gt;前端优化的目的&lt;/h3&gt;&lt;p&gt;前端包括HTML、CSS、Javascript、Image、Flash等各种各样的资源，针对方方面面
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://melodyyyyy.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Javascript跨域</title>
    <link href="http://melodyyyyy.com/2018/05/21/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://melodyyyyy.com/2018/05/21/跨域/</id>
    <published>2018-05-21T07:56:18.000Z</published>
    <updated>2018-07-03T08:57:16.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>跨域指的是从一个域名的网页去请求另一个域名的资源，只要协议、域名、端口有任何一个不同就被当作不同的域，之间的请求就是跨域操作。但是一般情况下由于浏览器对javascript的安全限制，跨域访问是受限制的。</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>所谓同源策略是指域名、协议、端口均相同。</p><table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">说明</th><th style="text-align:left">是否允许通信</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="http://www.baidu.com/b.js" target="_blank" rel="noopener">http://www.baidu.com/b.js</a></td><td style="text-align:left">域名、协议、端口均相同</td><td style="text-align:left">允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com:8080/a.js" target="_blank" rel="noopener">http://www.baidu.com:8080/a.js</a><br><a href="http://www.baidu.com/b.js" target="_blank" rel="noopener">http://www.baidu.com/b.js</a></td><td style="text-align:left">同一域名、不同端口</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="https://www.baidu.com/b.js" target="_blank" rel="noopener">https://www.baidu.com/b.js</a></td><td style="text-align:left">同一域名、不同协议</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="http://192.168.1.23/b.js" target="_blank" rel="noopener">http://192.168.1.23/b.js</a></td><td style="text-align:left">域名和域名对应IP</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="http://www.google.com/b.js" target="_blank" rel="noopener">http://www.google.com/b.js</a></td><td style="text-align:left">不同域名</td><td style="text-align:left">不允许</td></tr></tbody></table><p>需要注意的是：<br>1.如果是协议和端口造成的跨域问题”前台”是无能为力的。<br>2.域仅仅是通过URL首部来识别，不会尝试判断相同的IP地址对应着两个域或者两个域是否在同一个IP上。</p><h3 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h3><p>限制跨域主要是为了安全考虑：如果一个网页可以随意地访问另一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。<br>1.做一个假网站，用iframe嵌套一个银行网站mybank.com；<br>2.把iframe宽高调整到页面全部，伪装成银行网站，这样用户进来除了域名，别的部分和银行的网站没有任何差别；<br>3.此时用户输入帐号和密码，我们主网站可以跨域访问到mybank.com的dom节点，拿到用户的输入，那么就完成一次攻击。<br>所以说有了跨域限制之后我们才能更安全的上网。</p><h3 id="跨域的解决方式"><a href="#跨域的解决方式" class="headerlink" title="跨域的解决方式"></a>跨域的解决方式</h3><h4 id="1-跨域资源共享"><a href="#1-跨域资源共享" class="headerlink" title="1.跨域资源共享"></a>1.跨域资源共享</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。<br>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。<br>只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//指定允许其他域名访问</span><br><span class="line">&apos;Access-Control-Allow-Origin:*&apos;//或指定域</span><br><span class="line">//响应类型</span><br><span class="line">&apos;Access-Control-Allow-Methods:GET,POST&apos;</span><br><span class="line">//响应头设置</span><br><span class="line">&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;</span><br></pre></td></tr></table></figure></p><h4 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h4><p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。<br>JSONP的原理：通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用javascript动态加载一个script文件，同时定义一个callback函数给script执行而已。）<br>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：<br>有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://example.com/data.php,那么a.html中的代码就可以这样：" target="_blank" rel="noopener">http://example.com/data.php,那么a.html中的代码就可以这样：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function dosomething(jsondata)&#123;</span><br><span class="line">        //处理获得的json数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$callback = $_GET[&apos;callback&apos;];//得到回调函数名</span><br><span class="line">$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据</span><br><span class="line">echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;//输出</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><br>最终，输出结果为：dosomething([‘a’,’b’,’c’]);<br>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $.getJSON(&apos;http://example.com/data.php?callback=?,function(jsondata)&apos;)&#123;</span><br><span class="line">        //处理获得的json数据</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p><ul><li>JSONP的优缺点<br>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。<br>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li><li>CORS和JSONP对比<br>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li></ul><h4 id="3-document-domain来跨子域"><a href="#3-document-domain来跨子域" class="headerlink" title="3.document.domain来跨子域"></a>3.document.domain来跨子域</h4><p>浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。<br>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：<br>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 和 <a href="http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com" target="_blank" rel="noopener">http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com</a> 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</p><ul><li>在页面 <a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 中设置document.domain:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.domain = &apos;example.com&apos;;//设置成主域</span><br><span class="line">    function test()&#123;</span><br><span class="line">        alert(document.getElementById(&apos;￼iframe&apos;).contentWindow);//contentWindow 可取得子窗口的 window 对象</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>在页面 <a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a> 中也设置document.domain:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.domain = &apos;example.com&apos;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>注意：修改document.domain的方法只适用于不同子域的框架间的交互。</li></ul><h4 id="4-使用window-name来进行跨域"><a href="#4-使用window-name来进行跨域" class="headerlink" title="4.使用window.name来进行跨域"></a>4.使用window.name来进行跨域</h4><p>window.name跨域同样是受到同源策略限制，父框架和子框架的src必须指向统一域名。window.name的优势在于，name的值在不同的页面(或者不同的域名)，加载后仍然存在，除非你显示的更改。并且支持的长度达到2M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">   iframe.style.display = &apos;none&apos;;</span><br><span class="line">   var state = 0;</span><br><span class="line"></span><br><span class="line">   iframe.onload = function() &#123;</span><br><span class="line">     if(state === 1) &#123;</span><br><span class="line">         var data = iframe.contentWindow.name;</span><br><span class="line">         console.log(data);</span><br><span class="line">         iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">         iframe.contentWindow.close();</span><br><span class="line">         document.body.removeChild(iframe);</span><br><span class="line">     &#125; else if(state === 0) &#123;</span><br><span class="line">         state = 1;</span><br><span class="line">         iframe.contentWindow.location = </span><br><span class="line">         &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   window.name = &quot;hello&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="5-location-hash跨域"><a href="#5-location-hash跨域" class="headerlink" title="5.location.hash跨域"></a>5.location.hash跨域</h4><p>location.hash方式跨域，是子框架具有修改父框架src的hash值，通过这个属性进行传递数据，且更改hash值，页面不会刷新。但是传递的数据的字节数是有限的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">   iframe.style.display = &apos;none&apos;;</span><br><span class="line">   var state = 0;</span><br><span class="line"></span><br><span class="line">   iframe.onload = function() &#123;</span><br><span class="line">     if(state === 1) &#123;</span><br><span class="line">         var data = window.location.hash;</span><br><span class="line">         console.log(data);</span><br><span class="line">         iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">         iframe.contentWindow.close();</span><br><span class="line">         document.body.removeChild(iframe);</span><br><span class="line">     &#125; else if(state === 0) &#123;</span><br><span class="line">         state = 1;</span><br><span class="line">         iframe.contentWindow.location = </span><br><span class="line">         &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   parent.location.hash = &quot;world&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="6-使用postMessage实现页面之间通信"><a href="#6-使用postMessage实现页面之间通信" class="headerlink" title="6.使用postMessage实现页面之间通信"></a>6.使用postMessage实现页面之间通信</h4><p>window.postMessage(message,targetOrigin)  方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//a页面http://www.test.com/a.html代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   function onLoad()&#123;</span><br><span class="line">var iframe=document.getElementById(&apos;iframe&apos;);</span><br><span class="line">var win=iframe.contentWindow;//获取window对象</span><br><span class="line">win.postMessage(&apos;来自页面a的信息&apos;,&apos;*&apos;)//向不同域的b页面发送消息</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test.com/b.html&quot; onload=&quot;onLoad()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//b页面http://www.test.com/b.html代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   window.onmessage=function(e)&#123;//注册message事件来接收消息</span><br><span class="line">e=e||event;//获取事件对象</span><br><span class="line">alert(e.data);//通过data属性得到传送的消息</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实际情况下，一般用cors，jsonp等常见方法就可以了。不过遇到了一些非常规情况，我们还是需要知道有更多的方法可以选择的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;跨域指的是从一个域名的网页去请求另一个域名的资源，只要协议、域名、端口有任何一个不同就被当作不同的域，之间的请求就是跨域操作。但是一般情况下
      
    
    </summary>
    
    
      <category term="跨域" scheme="http://melodyyyyy.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js深拷贝和浅拷贝</title>
    <link href="http://melodyyyyy.com/2018/05/06/copy/"/>
    <id>http://melodyyyyy.com/2018/05/06/copy/</id>
    <published>2018-05-06T06:37:14.000Z</published>
    <updated>2018-06-25T07:50:27.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JS的深拷贝(Deep Copy)和浅拷贝(Shallow Copy)，只是针对数组和对象这样复杂数据类型的复制问题。深拷贝和浅拷贝都可以实现在已有对象上再生一份的作用，但是深拷贝会在堆中开辟一块新的内存地址用于存放复制的对象，拷贝后的对象余原来的对象是完全隔离的，互不影响，而浅拷贝仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。深拷贝和浅拷贝的最根本区别在于是否真正获取了一个对象的复制实例而不是引用。</p><h3 id="数组的深浅拷贝"><a href="#数组的深浅拷贝" class="headerlink" title="数组的深浅拷贝"></a>数组的深浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];</span><br><span class="line">var arrto = arr;</span><br><span class="line">arrto[1] = &quot;test&quot;;</span><br><span class="line">console.log(&quot;数组的原始值：&quot; + arr);    //数组的原始值：One,test,Three</span><br><span class="line">console.log(&quot;数组的新值：&quot; + arrto);    //数组的新值：One,test,Three</span><br></pre></td></tr></table></figure><p>这种直接赋值的方式就是浅拷贝，很多时候我们需要arr的值不变，这时候就需要用到深拷贝。<br>1.js的slice函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];</span><br><span class="line">var arrto = arr.slice(0);</span><br><span class="line">arrto[1] = &quot;set Map&quot;;</span><br><span class="line">console.log(&quot;数组的原始值：&quot; + arr);    //数组的原始值：One,Two,Three</span><br><span class="line">console.log(&quot;数组的新值：&quot; + arrto);    //数组的新值：One,set Map,Three</span><br></pre></td></tr></table></figure><br>2.js的concat方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];</span><br><span class="line">var arrto = arr.concat();;</span><br><span class="line">arrto[1] = &quot;set Map To&quot;;</span><br><span class="line">console.log(&quot;数组的原始值：&quot; + arr);    //数组的原始值：One,Two,Three</span><br><span class="line">console.log(&quot;数组的新值：&quot; + arrto);    //数组的新值：One,set Map To,Three</span><br></pre></td></tr></table></figure></p><h3 id="对象的深浅拷贝"><a href="#对象的深浅拷贝" class="headerlink" title="对象的深浅拷贝"></a>对象的深浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var json1 = &#123;&quot;a&quot;:&quot;李鹏&quot;,&quot;arr1&quot;:[1,2,3]&#125;</span><br><span class="line">function copy(obj1) &#123;</span><br><span class="line">　　　　var obj2 = &#123;&#125;;</span><br><span class="line">　　　　for (var i in obj1) &#123;</span><br><span class="line">　　　　　　obj2[i] = obj1[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return obj2;</span><br><span class="line">&#125;</span><br><span class="line">var json2 = copy(json1);</span><br><span class="line">json1.arr1.push(4);</span><br><span class="line">alert(json1.arr1);  //1234</span><br><span class="line">alert(json2.arr1)  //1234</span><br></pre></td></tr></table></figure><p>深拷贝的话我们可以通过递归的思想来做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var json1=&#123;&quot;name&quot;:&quot;鹏哥&quot;,&quot;age&quot;:18,&quot;arr1&quot;:[1,2,3,4,5],&quot;string&quot;:&apos;afasfsafa&apos;,&quot;arr2&quot;:[1,2,3,4,5],&quot;arr3&quot;:[&#123;&quot;name1&quot;:&quot;李鹏&quot;&#125;,&#123;&quot;job&quot;:&quot;前端开发&quot;&#125;]&#125;;</span><br><span class="line">var json2=&#123;&#125;;</span><br><span class="line">function copy(obj1,obj2)&#123;</span><br><span class="line">  var obj2=obj2||&#123;&#125;; //最初的时候给它一个初始值=它自己或者是一个json</span><br><span class="line">  for(var name in obj1)&#123;</span><br><span class="line">    if(typeof obj1[name] === &quot;object&quot;)&#123; //先判断一下obj[name]是不是一个对象</span><br><span class="line">      obj2[name]= (obj1[name].constructor===Array)?[]:&#123;&#125;; //我们让要复制的对象的name项=数组或者是json</span><br><span class="line">      copy(obj1[name],obj2[name]); //然后来无限调用函数自己 递归思想</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      obj2[name]=obj1[name];  //如果不是对象，直接等于即可，不会发生引用。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj2; //然后在把复制好的对象给return出去</span><br><span class="line">&#125;</span><br><span class="line">json2=copy(json1,json2)</span><br><span class="line">json1.arr1.push(6);</span><br><span class="line">alert(json1.arr1);  //123456</span><br><span class="line">alert(json2.arr1);  //12345</span><br></pre></td></tr></table></figure><br>以上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JS的深拷贝(Deep Copy)和浅拷贝(Shallow Copy)，只是针对数组和对象这样复杂数据类型的复制问题。深拷贝和浅拷贝都可以实
      
    
    </summary>
    
    
      <category term="深拷贝" scheme="http://melodyyyyy.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="http://melodyyyyy.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>webStorage</title>
    <link href="http://melodyyyyy.com/2018/03/17/sessionStorage/"/>
    <id>http://melodyyyyy.com/2018/03/17/sessionStorage/</id>
    <published>2018-03-17T05:57:55.000Z</published>
    <updated>2018-03-27T09:14:13.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cookie的缺点"><a href="#cookie的缺点" class="headerlink" title="cookie的缺点"></a>cookie的缺点</h3><p>webStorage的概念和cookie相似，但cookie的数量和长度有限制，每个domain最多只能有20条cookie，每个cookie长度不能超过4kb；而且cookie存在安全性问题，如果cookie被人拦截了，对方可以取得所有的session信息，即便加密也于事无补，因为拦截者不需要知道cookie的意义，他只需要把cookie转发就能达到目的；cookie的API不够灵活，需要自己封装setCookie、getCookie等方法；另外cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，每次请求一个新页面的时候cookie都会被发送过去，无形中浪费了带宽。<br>但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而webStorage仅仅是为了在本地“存储”数据而生，webStorage的意图在于解决本地本来不应该用cookie做，却不得不用cookie的本地存储。</p><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><p>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);                      //保存数据到sessionStorage</span><br><span class="line">var data = sessionStorage.getItem(&apos;key&apos;);                    //从sessionStorage获取数据</span><br><span class="line">sessionStorage.removeItem(&apos;key&apos;);                            //从sessionStorage删除保存的数据</span><br><span class="line">sessionStorage.clear();                                      //从sessionStorage删除所有保存的数据</span><br></pre></td></tr></table></figure><br>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&apos;myCat&apos;, &apos;Tom&apos;);                        //保存数据到localStorage</span><br><span class="line">var cat = localStorage.getItem(&quot;myCat&quot;);                     //从localStorage获取数据</span><br><span class="line">localStorage.removeItem(&quot;myCat&quot;);                            //从localStorage删除保存的数据</span><br><span class="line">localStorage.clear();                                        //从localStorage删除所有保存的数据</span><br></pre></td></tr></table></figure></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>localStorage可以用来统计页面访问次数。<br>sessionStorage可以用来统计当前页面元素的点击次数。<br>cookie一般存储用户名密码相关信息，一般使用escape转义编码后存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;cookie的缺点&quot;&gt;&lt;a href=&quot;#cookie的缺点&quot; class=&quot;headerlink&quot; title=&quot;cookie的缺点&quot;&gt;&lt;/a&gt;cookie的缺点&lt;/h3&gt;&lt;p&gt;webStorage的概念和cookie相似，但cookie的数量和长度有限制，每个
      
    
    </summary>
    
    
      <category term="sessionStorage" scheme="http://melodyyyyy.com/tags/sessionStorage/"/>
    
      <category term="localStorage" scheme="http://melodyyyyy.com/tags/localStorage/"/>
    
  </entry>
  
  <entry>
    <title>在vue项目中使用sass</title>
    <link href="http://melodyyyyy.com/2018/01/18/sass/"/>
    <id>http://melodyyyyy.com/2018/01/18/sass/</id>
    <published>2018-01-18T01:18:19.000Z</published>
    <updated>2018-01-19T08:24:09.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p><h3 id="在vue项目中使用sass"><a href="#在vue项目中使用sass" class="headerlink" title="在vue项目中使用sass"></a>在vue项目中使用sass</h3><p>我的项目是用vue-cli脚手架搭建的。<br>1.引入依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install node-sass --save-dev</span><br><span class="line">npm install sass-loader --save-dev</span><br></pre></td></tr></table></figure><br>2.修改style标签<br>将组件里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>这样的话，就可以在项目中使用sass了！</p><h3 id="sass基础语法"><a href="#sass基础语法" class="headerlink" title="sass基础语法"></a>sass基础语法</h3><ul><li>使用变量</li></ul><p>sass让人们受益的一个重要特性就是它为css引入了变量，以后可以通过变量名来引用这个属性值，不需要再重复书写，sass使用$符号来标识变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$mainColor:#eef1f6;</span><br><span class="line">.content&#123;</span><br><span class="line">background-color:$mainColor;</span><br><span class="line">border:1px solid $mainColor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>嵌套</li></ul><p>sass允许嵌套，避免重复的写同一个选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">color:#fff;</span><br><span class="line">&#125;</span><br><span class="line">.content p&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">&#125;</span><br><span class="line">.content span&#123;</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况可以使用嵌套写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">color:#fff;</span><br><span class="line">p&#123;font-size:14px;&#125;</span><br><span class="line">span&#123;font-weight:bold;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的话避免重复书写同一个选择器，可读性也更强了。<br>1.父选择器的标识符&amp;；<br>大多数情况下简单的嵌套都没问题，但如果想在嵌套的选择器里面应用一个类似:hover的伪类，sass就无法工作，解决的办法是使用父选择器&amp;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.content a&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">&#125;</span><br><span class="line">.content a:hover&#123;</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种情况可以利用父选择器嵌套为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.content a&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">&amp;:hover&#123;font-weight:bold;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.群组选择器的嵌套<br>如果你需要在一个特定的容器元素内对一个群组选择器进行修饰，为了避免重复书写容器元素的选择器，可以使用嵌套。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125;</span><br></pre></td></tr></table></figure><br>这种情况可以用嵌套写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  h1, h2, h3 &#123;margin-bottom: .8em&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.子组合选择器和同层组合选择器:&gt;、+和～<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">article section &#123; margin: 5px &#125;//选择article下的所有命中section选择器的元素</span><br><span class="line">article &gt; section &#123; border: 1px solid #ccc &#125;//选择article下紧跟着的子元素命中section选择器的元素</span><br><span class="line">header + p &#123; font-size: 1.1em &#125;//选择header元素后紧跟的p元素</span><br><span class="line">article ～ article &#123; border-top: 1px dashed #ccc &#125;//选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</span><br></pre></td></tr></table></figure></p><ul><li>导入SASS文件</li></ul><p>sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求。<br><img src="/assets/blogImg/import.png" alt=""></p><ul><li>混合器</li></ul><p>当你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过sass的混合器实现大段样式的重用。混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners &#123;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后就可以在你的样式表中通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notice &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  border: 2px solid #00aa00;</span><br><span class="line">  @include rounded-corners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>混合器并不一定总得生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当@include混合器时，参数其实就是可以赋值给css属性值的变量。如果你写过JavaScript，这种方式跟JavaScript的function很像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-colors($normal, $hover, $visited) &#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover &#123; color: $hover; &#125;</span><br><span class="line">  &amp;:visited &#123; color: $visited; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当混合器被@include时，你可以把它当作一个css函数来传参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  @include link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>使用选择器继承来精简CSS</li></ul><p>使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上边的代码中，.seriousError将会继承样式表中任何位置处为.error定义的所有样式。以class=”seriousError” 修饰的html元素最终的展示效果就好像是class=”seriousError error”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sass大法好！以后在vue中尽情使用sass吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、
      
    
    </summary>
    
    
      <category term="sass" scheme="http://melodyyyyy.com/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>Linux下vue-cli热加载失效</title>
    <link href="http://melodyyyyy.com/2018/01/02/hotreload/"/>
    <id>http://melodyyyyy.com/2018/01/02/hotreload/</id>
    <published>2018-01-02T05:38:06.000Z</published>
    <updated>2018-01-02T05:55:30.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热加载失效"><a href="#热加载失效" class="headerlink" title="热加载失效"></a>热加载失效</h3><p>用vue-cli+webpack+element+axios+vue-router搭建了一个后台管理系统，用得很顺手，元旦过后启动项目发现热加载突然失效了。修改代码后保存，页面不发生改变，手动刷新也不起作用，只能重新启动项目才能看到修改后的效果。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p>OK，问题解决了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;热加载失效&quot;&gt;&lt;a href=&quot;#热加载失效&quot; class=&quot;headerlink&quot; title=&quot;热加载失效&quot;&gt;&lt;/a&gt;热加载失效&lt;/h3&gt;&lt;p&gt;用vue-cli+webpack+element+axios+vue-router搭建了一个后台管理系统，用得很顺手
      
    
    </summary>
    
    
      <category term="vue-cli" scheme="http://melodyyyyy.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>webpack3+vue2 项目搭建(without vue-cli)</title>
    <link href="http://melodyyyyy.com/2017/12/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://melodyyyyy.com/2017/12/13/搭建博客/</id>
    <published>2017-12-13T09:47:18.000Z</published>
    <updated>2017-12-22T03:24:58.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue-cli是官方提供的快速构建单页应用的脚手架，按官方文档跑了一遍确实非常强大，但牵扯的东西比较多，所以存在了一些疑惑，比如说整个项目是怎么组织运行起来的，main.js-APP.vue-各个组件之间是怎样相互引用的？为了加深自己的理解，不借助官方构建工具，利用webpack3+vue2自行构建一个类似于官方的项目结构，去体会它的运作机制。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装node.js<br>根据自己的操作系统去<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网</a>下载安装包,安装完毕之后就可以使用npm了。npm是随同node.js一起安装的包管理工具，允许用户从npm服务器下载别人编写的第三方包到本地使用；允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用；允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。<br>npm的包安装分本地安装跟全局安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;      # 本地安装</span><br><span class="line">$ npm install &lt;Module Name&gt; -g   # 全局安装</span><br></pre></td></tr></table></figure><br>因为npm是从国外服务器下载包，受网络影响大，可能出现异常，因此淘宝团队做了一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步,所以你可以使用定制的cnpm命令行工具代替默认的npm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>1.新建一个文件夹,进入项目根目录，初始化npm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir vue-webpack</span><br><span class="line">cd vue-webpack</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><br>然后会让你输入文件名，版本，描述等信息，一路回车就好，最后根目录下面会产生一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。<br>2.安装vue包到项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue</span><br></pre></td></tr></table></figure><br>注意：npm在安装vue包时，有两种命令参数可以把它们的信息写入package.json文件，一个是npm install - -save，另一个是npm install - -save-dev，- -save会把依赖包名称添加到package.json文件的dependencies 键下，而- -save-dev则把依赖包名称添加到devDependencies 键下。npm文档解释dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，dependencies下的模块，则是我们发布后还需要依赖的模块，譬如像Vue框架，我们在开发完后肯定还要依赖它，否则就运行不了。<br>3.创建目录结构<br>在根目录下创建src文件夹，dist文件夹和index.html，接下来在src文件夹下面创建入口文件main.js，项目根组件App.js和组件目录components，并且components目录下创建两个组件component1.js和components2.js，当前目录结构如下：<br><img src="/assets/blogImg/folder.png" alt=""></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>components文件夹下存放的是项目中的除根组件外的其他组件，我们在写这些组件的时候应该遵循的一个原则就是：与外界隔绝，不做任何与外界耦合的假设。首先编写组件component1.js跟component2.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">   template: &apos;&lt;p&gt;&lt;/p&gt;&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">message:&#123;</span><br><span class="line">type:String,</span><br><span class="line">default: &apos;this is compontent1&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">   template: &apos;&lt;p&gt;&lt;/p&gt;&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">message:&#123;</span><br><span class="line">type:String,</span><br><span class="line">default: &apos;this is compontent2&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来我们需要在根组件中引用这两个组件，根组件的写法遵循同样的原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import component1 from &apos;./components/component1.js&apos;</span><br><span class="line">import component2 from &apos;./components/component2.js&apos;</span><br><span class="line">export default&#123;</span><br><span class="line">   template: &quot;&lt;div&gt;&lt;h1&gt;this is vue app&lt;/h1&gt;&lt;component1&gt;&lt;/component1&gt;&lt;component2&gt;&lt;/component2&gt;&lt;/div&gt;&quot;,</span><br><span class="line">   components: &#123;</span><br><span class="line">&apos;component1&apos;: component1,</span><br><span class="line">&apos;component2&apos;: component2,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要使用组件，首先要将其import导入，因为组件中导出的写法是export default，所以我们在这可以给组件对象随意命名（import后紧随的’component1’就是我们的命名），这是ES6的语法规则。记住：每个组件对象我们都需要使用export default进行导出，因为这样外界才可以调用它，并且将 给此组件的命名权 递交给使用者。<br>我们看到，在根组件中我们有components选项，用来注册将使用的组件（局部注册），此选项对象中的key将作为模板中标签，value为其他组件对象。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>组件都写好了，那如何将其挂载到html页面中呢，这个时候我们需要一个桥梁，就是main.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import component1 from &apos;./components/component1.js&apos;</span><br><span class="line">import component2 from &apos;./components/component2.js&apos;</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import app from &apos;./App.js&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">template: &apos;&lt;app&gt;&lt;/app&gt;&apos;,</span><br><span class="line">components: &#123;&apos;app&apos;:app&#125;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><br>首先导入Vue，接着导入App根组件，将其注册为Vue实例的组件，并且在模板中使用它（template:’’），然后将这个Vue实例挂载到index.html中id为app的元素中。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在打包之前我们需要先修改vue npm包的package.json文件，将默认导出的‘只包含运行时’改为‘完整版’，即将如下两项的’runtime’去掉（运行时不包含编译器 | 编译器作用：用来将模板字符串编译成为 JavaScript 渲染函数的代码&gt;，因此组件对象不支持 template 选项）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;dist/vue.common.js&quot;,</span><br><span class="line">&quot;module&quot;: &quot;dist/vue.esm.js&quot;,</span><br></pre></td></tr></table></figure><br>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。<br>Webpack可以使用npm安装，首先全局安装，然后安装到项目目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure><br>安装完成后，webpack可以在终端中使用，在基本的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;   # &#123;extry file&#125;处填写入口文件的路径  &#123;destination for bundled file&#125;处填写打包文件的存放路径</span><br></pre></td></tr></table></figure><br>在本项目中，入口文件是src目录下的main.js，我们把打包命名为main.bundle.js存放在dist目录下，因此在项目根目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/main.bundle.js</span><br></pre></td></tr></table></figure><br>执行完成之后我们可以在dist目录下看到打包好的文件，现在我们将打包好的文件引入index页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Vue App&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;dist/main.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>现在打开index.html，可以看到如下结果：<br><img src="/assets/blogImg/index.png" alt=""><br>有没有很激动？单你肯定觉得这条指令比较复杂，在终端进行复杂的操作其实不太方便且容易出错，因此可以通过配置文件来使用webpack。</p><h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>webpack拥有很多其他的比较高级的功能，这些功能其实都可以通过命令行模式实现，但是这样不太方便且容易出错，解决方法就是定义一个配置文件，这个配置文件其实也是一个简单的javascript模块，我们可以把所有与打包相关的信息放在里面。<br>现在我们在根目录下新建webpack.config.js文件，在其中做简单的配置，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。有了这个配置之后，再打包文件，只需在终端里运行webpack命令就可以了，这条命令会自动引用webpack.config.js文件中的配置选项。</p><h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>由于npm可以引导任务执行，在对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面的webpack命令。在package.json中对scripts对象进行相关的设置即可，设置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot; : &quot;webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，现在我们在命令行中输入npm start就可以同样完成打包了。</p><h3 id="Webpack的强大功能"><a href="#Webpack的强大功能" class="headerlink" title="Webpack的强大功能"></a>Webpack的强大功能</h3><p>使用webpack构建本地服务器<br>想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><br>devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">这里</a><br><img src="/assets/blogImg/devserver.png" alt=""><br>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot; : &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>在终端中输入npm run server即可在本地的8080端口查看结果。</p><h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h3><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; ,</span><br><span class="line">  plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这个插件，打包后的JS文件显示如下：<br><img src="/assets/blogImg/banner.png" alt=""><br>webpack还有很多常用的插件，具体用法请参照<a href="https://doc.webpack-china.org/concepts/plugins/" target="_blank" rel="noopener">官网</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，对于用webpack+vue搭建一个简单的骨架已经有了一定的理解，对项目运作机制以及各个组件间的引用也有了相应的了解，能够更好的探索其他关于webpack跟vue的知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Vue-cli是官方提供的快速构建单页应用的脚手架，按官方文档跑了一遍确实非常强大，但牵扯的东西比较多，所以存在了一些疑惑，比如说整个项目是
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://melodyyyyy.com/tags/webpack/"/>
    
      <category term="vue" scheme="http://melodyyyyy.com/tags/vue/"/>
    
  </entry>
  
</feed>
