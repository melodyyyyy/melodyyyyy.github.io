<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>melody</title>
  
  <subtitle>keep moving</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://melodyyyyy.com/"/>
  <updated>2018-06-28T08:10:42.201Z</updated>
  <id>http://melodyyyyy.com/</id>
  
  <author>
    <name>melody</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tensorflow</title>
    <link href="http://melodyyyyy.com/2018/06/28/tensorflow/"/>
    <id>http://melodyyyyy.com/2018/06/28/tensorflow/</id>
    <published>2018-06-28T08:10:42.000Z</published>
    <updated>2018-06-28T08:10:42.201Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript跨域</title>
    <link href="http://melodyyyyy.com/2018/05/21/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://melodyyyyy.com/2018/05/21/跨域/</id>
    <published>2018-05-21T07:56:18.000Z</published>
    <updated>2018-07-03T08:42:35.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>跨域指的是从一个域名的网页去请求另一个域名的资源，只要协议、域名、端口有任何一个不同就被当作不同的域，之间的请求就是跨域操作。但是一般情况下由于浏览器对javascript的安全限制，跨域访问是受限制的。</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>所谓同源策略是指域名、协议、端口均相同。</p><table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">说明</th><th style="text-align:left">是否允许通信</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="http://www.baidu.com/b.js" target="_blank" rel="noopener">http://www.baidu.com/b.js</a></td><td style="text-align:left">域名、协议、端口均相同</td><td style="text-align:left">允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com:8080/a.js" target="_blank" rel="noopener">http://www.baidu.com:8080/a.js</a><br><a href="http://www.baidu.com/b.js" target="_blank" rel="noopener">http://www.baidu.com/b.js</a></td><td style="text-align:left">同一域名、不同端口</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="https://www.baidu.com/b.js" target="_blank" rel="noopener">https://www.baidu.com/b.js</a></td><td style="text-align:left">同一域名、不同协议</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="http://192.168.1.23/b.js" target="_blank" rel="noopener">http://192.168.1.23/b.js</a></td><td style="text-align:left">域名和域名对应IP</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left"><a href="http://www.baidu.com/a.js" target="_blank" rel="noopener">http://www.baidu.com/a.js</a><br><a href="http://www.google.com/b.js" target="_blank" rel="noopener">http://www.google.com/b.js</a></td><td style="text-align:left">不同域名</td><td style="text-align:left">不允许</td></tr></tbody></table><p>需要注意的是：<br>1.如果是协议和端口造成的跨域问题”前台”是无能为力的。<br>2.域仅仅是通过URL首部来识别，不会尝试判断相同的IP地址对应着两个域或者两个域是否在同一个IP上。</p><h3 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h3><p>限制跨域主要是为了安全考虑：如果一个网页可以随意地访问另一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。<br>1.做一个假网站，用iframe嵌套一个银行网站mybank.com；<br>2.把iframe宽高调整到页面全部，伪装成银行网站，这样用户进来除了域名，别的部分和银行的网站没有任何差别；<br>3.此时用户输入帐号和密码，我们主网站可以跨域访问到mybank.com的dom节点，拿到用户的输入，那么就完成一次攻击。<br>所以说有了跨域限制之后我们才能更安全的上网。</p><h3 id="跨域的解决方式"><a href="#跨域的解决方式" class="headerlink" title="跨域的解决方式"></a>跨域的解决方式</h3><p>1.跨域资源共享<br>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。<br>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。<br>只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//指定允许其他域名访问</span><br><span class="line">&apos;Access-Control-Allow-Origin:*&apos;//或指定域</span><br><span class="line">//响应类型</span><br><span class="line">&apos;Access-Control-Allow-Methods:GET,POST&apos;</span><br><span class="line">//响应头设置</span><br><span class="line">&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;</span><br></pre></td></tr></table></figure><br>2.jsonp<br>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。<br>JSONP的原理：通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用javascript动态加载一个script文件，同时定义一个callback函数给script执行而已。）<br>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：<br>有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://example.com/data.php,那么a.html中的代码就可以这样：" target="_blank" rel="noopener">http://example.com/data.php,那么a.html中的代码就可以这样：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function dosomething(jsondata)&#123;</span><br><span class="line">        //处理获得的json数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$callback = $_GET[&apos;callback&apos;];//得到回调函数名</span><br><span class="line">$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据</span><br><span class="line">echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;//输出</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><br>最终，输出结果为：dosomething([‘a’,’b’,’c’]);<br>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $.getJSON(&apos;http://example.com/data.php?callback=?,function(jsondata)&apos;)&#123;</span><br><span class="line">        //处理获得的json数据</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p><ul><li>JSONP的优缺点<br>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。<br>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li><li>CORS和JSONP对比<br>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。<br>3.document.domain来跨子域<br>浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。<br>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：<br>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 和 <a href="http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com" target="_blank" rel="noopener">http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com</a> 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。<ul><li>在页面 <a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> 中设置document.domain:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.domain = &apos;example.com&apos;;//设置成主域</span><br><span class="line">    function test()&#123;</span><br><span class="line">        alert(document.getElementById(&apos;￼iframe&apos;).contentWindow);//contentWindow 可取得子窗口的 window 对象</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>在页面 <a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a> 中也设置document.domain:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.domain = &apos;example.com&apos;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>注意：修改document.domain的方法只适用于不同子域的框架间的交互。<br>4.使用window.name来进行跨域<br>window.name跨域同样是受到同源策略限制，父框架和子框架的src必须指向统一域名。window.name的优势在于，name的值在不同的页面(或者不同的域名)，加载后仍然存在，除非你显示的更改。并且支持的长度达到2M。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">   iframe.style.display = &apos;none&apos;;</span><br><span class="line">   var state = 0;</span><br><span class="line"></span><br><span class="line">   iframe.onload = function() &#123;</span><br><span class="line">     if(state === 1) &#123;</span><br><span class="line">         var data = iframe.contentWindow.name;</span><br><span class="line">         console.log(data);</span><br><span class="line">         iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">         iframe.contentWindow.close();</span><br><span class="line">         document.body.removeChild(iframe);</span><br><span class="line">     &#125; else if(state === 0) &#123;</span><br><span class="line">         state = 1;</span><br><span class="line">         iframe.contentWindow.location = </span><br><span class="line">         &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   window.name = &quot;hello&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>5.location.hash跨域<br>location.hash方式跨域，是子框架具有修改父框架src的hash值，通过这个属性进行传递数据，且更改hash值，页面不会刷新。但是传递的数据的字节数是有限的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//a页面的代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">   iframe.style.display = &apos;none&apos;;</span><br><span class="line">   var state = 0;</span><br><span class="line"></span><br><span class="line">   iframe.onload = function() &#123;</span><br><span class="line">     if(state === 1) &#123;</span><br><span class="line">         var data = window.location.hash;</span><br><span class="line">         console.log(data);</span><br><span class="line">         iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">         iframe.contentWindow.close();</span><br><span class="line">         document.body.removeChild(iframe);</span><br><span class="line">     &#125; else if(state === 0) &#123;</span><br><span class="line">         state = 1;</span><br><span class="line">         iframe.contentWindow.location = </span><br><span class="line">         &apos;http://m.zhuanzhuan.58.com:8887/b.html&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//b页面代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   parent.location.hash = &quot;world&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>6.使用postMessage实现页面之间通信<br>window.postMessage(message,targetOrigin)  方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//a页面http://www.test.com/a.html代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   function onLoad()&#123;</span><br><span class="line">var iframe=document.getElementById(&apos;iframe&apos;);</span><br><span class="line">var win=iframe.contentWindow;//获取window对象</span><br><span class="line">win.postMessage(&apos;来自页面a的信息&apos;,&apos;*&apos;)//向不同域的b页面发送消息</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test.com/b.html&quot; onload=&quot;onLoad()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//b页面http://www.test.com/b.html代码</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   window.onmessage=function(e)&#123;//注册message事件来接收消息</span><br><span class="line">e=e||event;//获取事件对象</span><br><span class="line">alert(e.data);//通过data属性得到传送的消息</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>实际情况下，一般用cors，jsonp等常见方法就可以了。不过遇到了一些非常规情况，我们还是需要知道有更多的方法可以选择的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;跨域指的是从一个域名的网页去请求另一个域名的资源，只要协议、域名、端口有任何一个不同就被当作不同的域，之间的请求就是跨域操作。但是一般情况下
      
    
    </summary>
    
    
      <category term="跨域" scheme="http://melodyyyyy.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js深拷贝和浅拷贝</title>
    <link href="http://melodyyyyy.com/2018/05/06/copy/"/>
    <id>http://melodyyyyy.com/2018/05/06/copy/</id>
    <published>2018-05-06T06:37:14.000Z</published>
    <updated>2018-06-25T07:50:27.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JS的深拷贝(Deep Copy)和浅拷贝(Shallow Copy)，只是针对数组和对象这样复杂数据类型的复制问题。深拷贝和浅拷贝都可以实现在已有对象上再生一份的作用，但是深拷贝会在堆中开辟一块新的内存地址用于存放复制的对象，拷贝后的对象余原来的对象是完全隔离的，互不影响，而浅拷贝仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。深拷贝和浅拷贝的最根本区别在于是否真正获取了一个对象的复制实例而不是引用。</p><h3 id="数组的深浅拷贝"><a href="#数组的深浅拷贝" class="headerlink" title="数组的深浅拷贝"></a>数组的深浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];</span><br><span class="line">var arrto = arr;</span><br><span class="line">arrto[1] = &quot;test&quot;;</span><br><span class="line">console.log(&quot;数组的原始值：&quot; + arr);    //数组的原始值：One,test,Three</span><br><span class="line">console.log(&quot;数组的新值：&quot; + arrto);    //数组的新值：One,test,Three</span><br></pre></td></tr></table></figure><p>这种直接赋值的方式就是浅拷贝，很多时候我们需要arr的值不变，这时候就需要用到深拷贝。<br>1.js的slice函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];</span><br><span class="line">var arrto = arr.slice(0);</span><br><span class="line">arrto[1] = &quot;set Map&quot;;</span><br><span class="line">console.log(&quot;数组的原始值：&quot; + arr);    //数组的原始值：One,Two,Three</span><br><span class="line">console.log(&quot;数组的新值：&quot; + arrto);    //数组的新值：One,set Map,Three</span><br></pre></td></tr></table></figure><br>2.js的concat方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];</span><br><span class="line">var arrto = arr.concat();;</span><br><span class="line">arrto[1] = &quot;set Map To&quot;;</span><br><span class="line">console.log(&quot;数组的原始值：&quot; + arr);    //数组的原始值：One,Two,Three</span><br><span class="line">console.log(&quot;数组的新值：&quot; + arrto);    //数组的新值：One,set Map To,Three</span><br></pre></td></tr></table></figure></p><h3 id="对象的深浅拷贝"><a href="#对象的深浅拷贝" class="headerlink" title="对象的深浅拷贝"></a>对象的深浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var json1 = &#123;&quot;a&quot;:&quot;李鹏&quot;,&quot;arr1&quot;:[1,2,3]&#125;</span><br><span class="line">function copy(obj1) &#123;</span><br><span class="line">　　　　var obj2 = &#123;&#125;;</span><br><span class="line">　　　　for (var i in obj1) &#123;</span><br><span class="line">　　　　　　obj2[i] = obj1[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return obj2;</span><br><span class="line">&#125;</span><br><span class="line">var json2 = copy(json1);</span><br><span class="line">json1.arr1.push(4);</span><br><span class="line">alert(json1.arr1);  //1234</span><br><span class="line">alert(json2.arr1)  //1234</span><br></pre></td></tr></table></figure><p>深拷贝的话我们可以通过递归的思想来做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var json1=&#123;&quot;name&quot;:&quot;鹏哥&quot;,&quot;age&quot;:18,&quot;arr1&quot;:[1,2,3,4,5],&quot;string&quot;:&apos;afasfsafa&apos;,&quot;arr2&quot;:[1,2,3,4,5],&quot;arr3&quot;:[&#123;&quot;name1&quot;:&quot;李鹏&quot;&#125;,&#123;&quot;job&quot;:&quot;前端开发&quot;&#125;]&#125;;</span><br><span class="line">var json2=&#123;&#125;;</span><br><span class="line">function copy(obj1,obj2)&#123;</span><br><span class="line">  var obj2=obj2||&#123;&#125;; //最初的时候给它一个初始值=它自己或者是一个json</span><br><span class="line">  for(var name in obj1)&#123;</span><br><span class="line">    if(typeof obj1[name] === &quot;object&quot;)&#123; //先判断一下obj[name]是不是一个对象</span><br><span class="line">      obj2[name]= (obj1[name].constructor===Array)?[]:&#123;&#125;; //我们让要复制的对象的name项=数组或者是json</span><br><span class="line">      copy(obj1[name],obj2[name]); //然后来无限调用函数自己 递归思想</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      obj2[name]=obj1[name];  //如果不是对象，直接等于即可，不会发生引用。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj2; //然后在把复制好的对象给return出去</span><br><span class="line">&#125;</span><br><span class="line">json2=copy(json1,json2)</span><br><span class="line">json1.arr1.push(6);</span><br><span class="line">alert(json1.arr1);  //123456</span><br><span class="line">alert(json2.arr1);  //12345</span><br></pre></td></tr></table></figure><br>以上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JS的深拷贝(Deep Copy)和浅拷贝(Shallow Copy)，只是针对数组和对象这样复杂数据类型的复制问题。深拷贝和浅拷贝都可以实
      
    
    </summary>
    
    
      <category term="深拷贝" scheme="http://melodyyyyy.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="http://melodyyyyy.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>webStorage</title>
    <link href="http://melodyyyyy.com/2018/03/17/sessionStorage/"/>
    <id>http://melodyyyyy.com/2018/03/17/sessionStorage/</id>
    <published>2018-03-17T05:57:55.000Z</published>
    <updated>2018-03-27T09:14:13.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cookie的缺点"><a href="#cookie的缺点" class="headerlink" title="cookie的缺点"></a>cookie的缺点</h3><p>webStorage的概念和cookie相似，但cookie的数量和长度有限制，每个domain最多只能有20条cookie，每个cookie长度不能超过4kb；而且cookie存在安全性问题，如果cookie被人拦截了，对方可以取得所有的session信息，即便加密也于事无补，因为拦截者不需要知道cookie的意义，他只需要把cookie转发就能达到目的；cookie的API不够灵活，需要自己封装setCookie、getCookie等方法；另外cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，每次请求一个新页面的时候cookie都会被发送过去，无形中浪费了带宽。<br>但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而webStorage仅仅是为了在本地“存储”数据而生，webStorage的意图在于解决本地本来不应该用cookie做，却不得不用cookie的本地存储。</p><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><p>html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);                      //保存数据到sessionStorage</span><br><span class="line">var data = sessionStorage.getItem(&apos;key&apos;);                    //从sessionStorage获取数据</span><br><span class="line">sessionStorage.removeItem(&apos;key&apos;);                            //从sessionStorage删除保存的数据</span><br><span class="line">sessionStorage.clear();                                      //从sessionStorage删除所有保存的数据</span><br></pre></td></tr></table></figure><br>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&apos;myCat&apos;, &apos;Tom&apos;);                        //保存数据到localStorage</span><br><span class="line">var cat = localStorage.getItem(&quot;myCat&quot;);                     //从localStorage获取数据</span><br><span class="line">localStorage.removeItem(&quot;myCat&quot;);                            //从localStorage删除保存的数据</span><br><span class="line">localStorage.clear();                                        //从localStorage删除所有保存的数据</span><br></pre></td></tr></table></figure></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>localStorage可以用来统计页面访问次数。<br>sessionStorage可以用来统计当前页面元素的点击次数。<br>cookie一般存储用户名密码相关信息，一般使用escape转义编码后存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;cookie的缺点&quot;&gt;&lt;a href=&quot;#cookie的缺点&quot; class=&quot;headerlink&quot; title=&quot;cookie的缺点&quot;&gt;&lt;/a&gt;cookie的缺点&lt;/h3&gt;&lt;p&gt;webStorage的概念和cookie相似，但cookie的数量和长度有限制，每个
      
    
    </summary>
    
    
      <category term="sessionStorage" scheme="http://melodyyyyy.com/tags/sessionStorage/"/>
    
      <category term="localStorage" scheme="http://melodyyyyy.com/tags/localStorage/"/>
    
  </entry>
  
  <entry>
    <title>在vue项目中使用sass</title>
    <link href="http://melodyyyyy.com/2018/01/18/sass/"/>
    <id>http://melodyyyyy.com/2018/01/18/sass/</id>
    <published>2018-01-18T01:18:19.000Z</published>
    <updated>2018-01-19T08:24:09.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p><h3 id="在vue项目中使用sass"><a href="#在vue项目中使用sass" class="headerlink" title="在vue项目中使用sass"></a>在vue项目中使用sass</h3><p>我的项目是用vue-cli脚手架搭建的。<br>1.引入依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install node-sass --save-dev</span><br><span class="line">npm install sass-loader --save-dev</span><br></pre></td></tr></table></figure><br>2.修改style标签<br>将组件里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>这样的话，就可以在项目中使用sass了！</p><h3 id="sass基础语法"><a href="#sass基础语法" class="headerlink" title="sass基础语法"></a>sass基础语法</h3><ul><li>使用变量</li></ul><p>sass让人们受益的一个重要特性就是它为css引入了变量，以后可以通过变量名来引用这个属性值，不需要再重复书写，sass使用$符号来标识变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$mainColor:#eef1f6;</span><br><span class="line">.content&#123;</span><br><span class="line">background-color:$mainColor;</span><br><span class="line">border:1px solid $mainColor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>嵌套</li></ul><p>sass允许嵌套，避免重复的写同一个选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">color:#fff;</span><br><span class="line">&#125;</span><br><span class="line">.content p&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">&#125;</span><br><span class="line">.content span&#123;</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况可以使用嵌套写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">color:#fff;</span><br><span class="line">p&#123;font-size:14px;&#125;</span><br><span class="line">span&#123;font-weight:bold;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的话避免重复书写同一个选择器，可读性也更强了。<br>1.父选择器的标识符&amp;；<br>大多数情况下简单的嵌套都没问题，但如果想在嵌套的选择器里面应用一个类似:hover的伪类，sass就无法工作，解决的办法是使用父选择器&amp;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.content a&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">&#125;</span><br><span class="line">.content a:hover&#123;</span><br><span class="line">font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种情况可以利用父选择器嵌套为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.content a&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">&amp;:hover&#123;font-weight:bold;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.群组选择器的嵌套<br>如果你需要在一个特定的容器元素内对一个群组选择器进行修饰，为了避免重复书写容器元素的选择器，可以使用嵌套。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125;</span><br></pre></td></tr></table></figure><br>这种情况可以用嵌套写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  h1, h2, h3 &#123;margin-bottom: .8em&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.子组合选择器和同层组合选择器:&gt;、+和～<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">article section &#123; margin: 5px &#125;//选择article下的所有命中section选择器的元素</span><br><span class="line">article &gt; section &#123; border: 1px solid #ccc &#125;//选择article下紧跟着的子元素命中section选择器的元素</span><br><span class="line">header + p &#123; font-size: 1.1em &#125;//选择header元素后紧跟的p元素</span><br><span class="line">article ～ article &#123; border-top: 1px dashed #ccc &#125;//选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素</span><br></pre></td></tr></table></figure></p><ul><li>导入SASS文件</li></ul><p>sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求。<br><img src="/assets/blogImg/import.png" alt=""></p><ul><li>混合器</li></ul><p>当你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过sass的混合器实现大段样式的重用。混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners &#123;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后就可以在你的样式表中通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notice &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  border: 2px solid #00aa00;</span><br><span class="line">  @include rounded-corners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>混合器并不一定总得生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当@include混合器时，参数其实就是可以赋值给css属性值的变量。如果你写过JavaScript，这种方式跟JavaScript的function很像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-colors($normal, $hover, $visited) &#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover &#123; color: $hover; &#125;</span><br><span class="line">  &amp;:visited &#123; color: $visited; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当混合器被@include时，你可以把它当作一个css函数来传参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  @include link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>使用选择器继承来精简CSS</li></ul><p>使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上边的代码中，.seriousError将会继承样式表中任何位置处为.error定义的所有样式。以class=”seriousError” 修饰的html元素最终的展示效果就好像是class=”seriousError error”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sass大法好！以后在vue中尽情使用sass吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、
      
    
    </summary>
    
    
      <category term="sass" scheme="http://melodyyyyy.com/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>Linux下vue-cli热加载失效</title>
    <link href="http://melodyyyyy.com/2018/01/02/hotreload/"/>
    <id>http://melodyyyyy.com/2018/01/02/hotreload/</id>
    <published>2018-01-02T05:38:06.000Z</published>
    <updated>2018-01-02T05:55:30.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热加载失效"><a href="#热加载失效" class="headerlink" title="热加载失效"></a>热加载失效</h3><p>用vue-cli+webpack+element+axios+vue-router搭建了一个后台管理系统，用得很顺手，元旦过后启动项目发现热加载突然失效了。修改代码后保存，页面不发生改变，手动刷新也不起作用，只能重新启动项目才能看到修改后的效果。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p>OK，问题解决了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;热加载失效&quot;&gt;&lt;a href=&quot;#热加载失效&quot; class=&quot;headerlink&quot; title=&quot;热加载失效&quot;&gt;&lt;/a&gt;热加载失效&lt;/h3&gt;&lt;p&gt;用vue-cli+webpack+element+axios+vue-router搭建了一个后台管理系统，用得很顺手
      
    
    </summary>
    
    
      <category term="vue-cli" scheme="http://melodyyyyy.com/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>webpack3+vue2 项目搭建(without vue-cli)</title>
    <link href="http://melodyyyyy.com/2017/12/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://melodyyyyy.com/2017/12/13/搭建博客/</id>
    <published>2017-12-13T09:47:18.000Z</published>
    <updated>2017-12-22T03:24:58.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue-cli是官方提供的快速构建单页应用的脚手架，按官方文档跑了一遍确实非常强大，但牵扯的东西比较多，所以存在了一些疑惑，比如说整个项目是怎么组织运行起来的，main.js-APP.vue-各个组件之间是怎样相互引用的？为了加深自己的理解，不借助官方构建工具，利用webpack3+vue2自行构建一个类似于官方的项目结构，去体会它的运作机制。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装node.js<br>根据自己的操作系统去<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网</a>下载安装包,安装完毕之后就可以使用npm了。npm是随同node.js一起安装的包管理工具，允许用户从npm服务器下载别人编写的第三方包到本地使用；允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用；允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。<br>npm的包安装分本地安装跟全局安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;      # 本地安装</span><br><span class="line">$ npm install &lt;Module Name&gt; -g   # 全局安装</span><br></pre></td></tr></table></figure><br>因为npm是从国外服务器下载包，受网络影响大，可能出现异常，因此淘宝团队做了一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步,所以你可以使用定制的cnpm命令行工具代替默认的npm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>1.新建一个文件夹,进入项目根目录，初始化npm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir vue-webpack</span><br><span class="line">cd vue-webpack</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><br>然后会让你输入文件名，版本，描述等信息，一路回车就好，最后根目录下面会产生一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。<br>2.安装vue包到项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue</span><br></pre></td></tr></table></figure><br>注意：npm在安装vue包时，有两种命令参数可以把它们的信息写入package.json文件，一个是npm install - -save，另一个是npm install - -save-dev，- -save会把依赖包名称添加到package.json文件的dependencies 键下，而- -save-dev则把依赖包名称添加到devDependencies 键下。npm文档解释dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，dependencies下的模块，则是我们发布后还需要依赖的模块，譬如像Vue框架，我们在开发完后肯定还要依赖它，否则就运行不了。<br>3.创建目录结构<br>在根目录下创建src文件夹，dist文件夹和index.html，接下来在src文件夹下面创建入口文件main.js，项目根组件App.js和组件目录components，并且components目录下创建两个组件component1.js和components2.js，当前目录结构如下：<br><img src="/assets/blogImg/folder.png" alt=""></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>components文件夹下存放的是项目中的除根组件外的其他组件，我们在写这些组件的时候应该遵循的一个原则就是：与外界隔绝，不做任何与外界耦合的假设。首先编写组件component1.js跟component2.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">   template: &apos;&lt;p&gt;&lt;/p&gt;&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">message:&#123;</span><br><span class="line">type:String,</span><br><span class="line">default: &apos;this is compontent1&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">   template: &apos;&lt;p&gt;&lt;/p&gt;&apos;,</span><br><span class="line">   props: &#123;</span><br><span class="line">message:&#123;</span><br><span class="line">type:String,</span><br><span class="line">default: &apos;this is compontent2&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来我们需要在根组件中引用这两个组件，根组件的写法遵循同样的原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import component1 from &apos;./components/component1.js&apos;</span><br><span class="line">import component2 from &apos;./components/component2.js&apos;</span><br><span class="line">export default&#123;</span><br><span class="line">   template: &quot;&lt;div&gt;&lt;h1&gt;this is vue app&lt;/h1&gt;&lt;component1&gt;&lt;/component1&gt;&lt;component2&gt;&lt;/component2&gt;&lt;/div&gt;&quot;,</span><br><span class="line">   components: &#123;</span><br><span class="line">&apos;component1&apos;: component1,</span><br><span class="line">&apos;component2&apos;: component2,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要使用组件，首先要将其import导入，因为组件中导出的写法是export default，所以我们在这可以给组件对象随意命名（import后紧随的’component1’就是我们的命名），这是ES6的语法规则。记住：每个组件对象我们都需要使用export default进行导出，因为这样外界才可以调用它，并且将 给此组件的命名权 递交给使用者。<br>我们看到，在根组件中我们有components选项，用来注册将使用的组件（局部注册），此选项对象中的key将作为模板中标签，value为其他组件对象。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>组件都写好了，那如何将其挂载到html页面中呢，这个时候我们需要一个桥梁，就是main.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import component1 from &apos;./components/component1.js&apos;</span><br><span class="line">import component2 from &apos;./components/component2.js&apos;</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import app from &apos;./App.js&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">template: &apos;&lt;app&gt;&lt;/app&gt;&apos;,</span><br><span class="line">components: &#123;&apos;app&apos;:app&#125;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><br>首先导入Vue，接着导入App根组件，将其注册为Vue实例的组件，并且在模板中使用它（template:’’），然后将这个Vue实例挂载到index.html中id为app的元素中。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在打包之前我们需要先修改vue npm包的package.json文件，将默认导出的‘只包含运行时’改为‘完整版’，即将如下两项的’runtime’去掉（运行时不包含编译器 | 编译器作用：用来将模板字符串编译成为 JavaScript 渲染函数的代码&gt;，因此组件对象不支持 template 选项）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;dist/vue.common.js&quot;,</span><br><span class="line">&quot;module&quot;: &quot;dist/vue.esm.js&quot;,</span><br></pre></td></tr></table></figure><br>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。<br>Webpack可以使用npm安装，首先全局安装，然后安装到项目目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure><br>安装完成后，webpack可以在终端中使用，在基本的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;   # &#123;extry file&#125;处填写入口文件的路径  &#123;destination for bundled file&#125;处填写打包文件的存放路径</span><br></pre></td></tr></table></figure><br>在本项目中，入口文件是src目录下的main.js，我们把打包命名为main.bundle.js存放在dist目录下，因此在项目根目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/main.bundle.js</span><br></pre></td></tr></table></figure><br>执行完成之后我们可以在dist目录下看到打包好的文件，现在我们将打包好的文件引入index页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Vue App&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;dist/main.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>现在打开index.html，可以看到如下结果：<br><img src="/assets/blogImg/index.png" alt=""><br>有没有很激动？单你肯定觉得这条指令比较复杂，在终端进行复杂的操作其实不太方便且容易出错，因此可以通过配置文件来使用webpack。</p><h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>webpack拥有很多其他的比较高级的功能，这些功能其实都可以通过命令行模式实现，但是这样不太方便且容易出错，解决方法就是定义一个配置文件，这个配置文件其实也是一个简单的javascript模块，我们可以把所有与打包相关的信息放在里面。<br>现在我们在根目录下新建webpack.config.js文件，在其中做简单的配置，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。有了这个配置之后，再打包文件，只需在终端里运行webpack命令就可以了，这条命令会自动引用webpack.config.js文件中的配置选项。</p><h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>由于npm可以引导任务执行，在对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面的webpack命令。在package.json中对scripts对象进行相关的设置即可，设置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot; : &quot;webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，现在我们在命令行中输入npm start就可以同样完成打包了。</p><h3 id="Webpack的强大功能"><a href="#Webpack的强大功能" class="headerlink" title="Webpack的强大功能"></a>Webpack的强大功能</h3><p>使用webpack构建本地服务器<br>想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><br>devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">这里</a><br><img src="/assets/blogImg/devserver.png" alt=""><br>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot; : &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>在终端中输入npm run server即可在本地的8080端口查看结果。</p><h3 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h3><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/src/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;main.bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; ,</span><br><span class="line">  plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这个插件，打包后的JS文件显示如下：<br><img src="/assets/blogImg/banner.png" alt=""><br>webpack还有很多常用的插件，具体用法请参照<a href="https://doc.webpack-china.org/concepts/plugins/" target="_blank" rel="noopener">官网</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，对于用webpack+vue搭建一个简单的骨架已经有了一定的理解，对项目运作机制以及各个组件间的引用也有了相应的了解，能够更好的探索其他关于webpack跟vue的知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Vue-cli是官方提供的快速构建单页应用的脚手架，按官方文档跑了一遍确实非常强大，但牵扯的东西比较多，所以存在了一些疑惑，比如说整个项目是
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://melodyyyyy.com/tags/webpack/"/>
    
      <category term="vue" scheme="http://melodyyyyy.com/tags/vue/"/>
    
  </entry>
  
</feed>
